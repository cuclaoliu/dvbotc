/***************************************************************************
 *   Copyright (C) 2007 by Damien Phillip Morrissey,,,   *
 *   dpm95@uow.edu.au   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include "dvbotc.h"
#include "scrambler.h"
//! Scrambler Pseudo-Randon Binary Generator
/**
 * This function generates a pseudo-random binary sequence based on the procedure outlined in the DVB standard.
 * @param byte_length Size of the resulting output in bytes
 * @param state_in Pointer to the variable containing the state information for the generator
 * @return Pointer to the PBRS generated by the function
 */
unsigned char* scrambler_prbs (int byte_length, unsigned char* state_in)
//function [byte_sequence, state_out] = scrambler_prbs (byte_length, state_in)
{
	unsigned char* data_out;		// For the returned values
	unsigned char* byte_sequence;		// More logical holding variabe for the data_out
	unsigned char* shift_register;		// More logical holding variable for the state
	int ii;					// Iterator variable
	int jj;					// Iterator variable
	unsigned char new_bit;			// A holder for a new bit

	// Allocate memory for the output
	MALLOC(data_out, byte_length);
	for(ii = 0; ii < byte_length; ii++)
	{
		data_out[ii] = 0;
	}
	byte_sequence = data_out;

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// Perform actions
	shift_register = state_in;
	for (ii = 0; ii < 8* byte_length; ii++)
	{
		if(shift_register[13] != shift_register[14] && (shift_register[13] == 0 || shift_register[14] == 0))
		{
			new_bit = 1;
		}
		else
		{
			new_bit = 0;
		}
		for(jj = 14; jj > 0; jj--)
		{
			shift_register[jj] = shift_register[jj-1];
		}
		shift_register[0] = new_bit;
		byte_sequence[(int)(ii/8)] = byte_sequence[(int)(ii/8)] << 1;
		if(new_bit == 1)
		{
			byte_sequence[(int)(ii/8)] = byte_sequence[(int)(ii/8)] | 0x1;
		}
	}

	/*	// Although C does bit xor with the ^, it is OK in this case as we are just
		// Using 1's and 0's in the shift_register array
		new_bit = shift_register[13]^shift_register[14];
		for(jj = 14; jj > 0; jj--)
		{
			shift_register[jj] = shift_register[jj-1];
		}
		shift_register[0] = new_bit;
		for(jj = 0;jj<byte_length;jj++)
		{
			byte_sequence[jj] = byte_sequence[jj] << 1;
			if(jj < byte_length - 1)
			{
				if(byte_sequence[jj+1] & 255)
				{
					// If the bits bit is set in the byte set the last of the previous
					byte_sequence[jj] = byte_sequence[jj] & 1;
				}
			}
		}
		if(new_bit)
		{
			byte_sequence[byte_length - 1] = byte_sequence[byte_length - 1] & 1;
		}
	}*/
  /*for i = 1:bit_length
    new_bit = xor (shift_register(14), shift_register(15));
    shift_register = [new_bit shift_register(1:14)];
    bit_sequence(i) = new_bit;
  end

  byte_sequence = bi2de(reshape(bit_sequence, 8, byte_length)', 'left-msb');
  state_out = shift_register;*/
  //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	return data_out;
}




/*struct tracked_array scrambler_prbs(int byte_length, int *state_in)
{
	// the state_in pointer referrs to a space that we modify directly
	// as we can not return more than one value in C directly
	// int r = 15;	// Size of the state_in array
	int i = 0;
	struct tracked_array data_out;
//function [byte_sequence, state_out] = scrambler_prbs (byte_length, state_in)

	//////////////////////////////////////////////
	// Global declarations
	//////////////////////////////////////////////
	//global DUMP;

	//////////////////////////////////////////////
	// Parameter checking
	//////////////////////////////////////////////
	//[should_be_one, r] = size (state_in);	
	//assert (should_be_one == 1, 'scramble', 'row vector expected');
	//assert (r == 15, 'scramble', 'inconsistent prbs state');
	
	//////////////////////////////////////////////
	// Debugging dump
	//////////////////////////////////////////////
	fprintf(dump_refs.main, "\tscrambler_prbs. (n=%d)\n", byte_length);

	//////////////////////////////////////////////
	// Perform actions
	int bit_length = 8 * byte_length;
	int *shift_register;
	//MALLOC(shift_register, 15*sizeof(char));
	//memcpy(shift_register, 15*sizeof(char), state_in);
	shift_register = state_in;
	
	unsigned char* bit_sequence;
	MALLOC(bit_sequence, byte_length*sizeof(char));
	for(i = 0; i < byte_length; i++)
	{
		bit_sequence[i] = 0;
	}
	//bit_sequence=zeros(bit_length,1);
	int new_bit = 0;
	int jj = 0;
	for (i = 0; i < bit_length; i++)
	{
		// this could be optimised through the use of an integer I think and using bit shifts
		//new_bit = xor (shift_register(14), shift_register(15));
		// Below we are implementing the matlab version of xor which works by looking at the non-zero array elements
		if(shift_register[13] == 0 && shift_register[14] !=0 ||
			shift_register[13] == 0 && shift_register[14] !=0 )
		{
			new_bit = 1;
		}
		else
		{
			new_bit = 0;
		}
		// End of strange xor
		for(jj = 0; jj < 14; jj++)
		{
			shift_register[14-jj]  = shift_register[13-jj];
		}
		shift_register[0] = new_bit;
		//shift_register = [new_bit shift_register(1:14)];
		if(i > 0)
		{
			for(jj = 0; jj < byte_length; jj++)
			{
				bit_sequence[jj] = bit_sequence[jj] << 1;
				if(jj < byte_length - 1)
				{
					if(bit_sequence[jj+1] & 0x00)
					{
						bit_sequence[jj] = bit_sequence[jj]  | 0x08;
					}
				}
			}
		}
		if(new_bit == 1)
		{
			bit_sequence[byte_length - 1] = bit_sequence[byte_length - 1]  | 0x08;
		}
	}

	//byte_sequence = bi2de(reshape(bit_sequence, 8, byte_length)', 'left-msb');
	//state_out = shift_register;
	data_out.data = bit_sequence;
	data_out.size = bit_length;
	return data_out;
	//////////////////////////////////////////////
}
*/
